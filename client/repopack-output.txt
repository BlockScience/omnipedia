This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-28T15:05:12.800Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
app/
  layout.tsx
  page.tsx
components/
  ArticleSelector.tsx
  ContentRenderer.tsx
  GenerateCitations.tsx
  Omnipedia.tsx
  RequirementsSidebar.tsx
  SectionFeedback.tsx
lib/
  data.ts
  json.ts
  types.ts
  utils.ts

================================================================
Repository Files
================================================================

================
File: app/layout.tsx
================
"use client";

import localFont from "next/font/local";
import "./globals.css";

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}

================
File: app/page.tsx
================
import { Omnipedia } from "@/components/Omnipedia";

export default function Page() {
  return <Omnipedia />;
}

================
File: components/ArticleSelector.tsx
================
import React from "react";
import useSWR from "swr";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import { ChevronDown } from "lucide-react";

export const ArticleSelector = ({
  onSelect,
}: {
  onSelect: (source: string, acronym: string) => void;
}) => {
  const acronyms = ["ADCYAP1", "AGK", "ATF1", "ABCC11", "ANLN"];
  const sources = ["wikipedia", "wikicrow"];

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" className="w-[200px] justify-between">
          Select Article
          <ChevronDown className="ml-2 h-4 w-4" />
        </Button>
      </DropdownMenuTrigger>

      <DropdownMenuContent className="w-[200px]">
        {sources.map((source) => (
          <DropdownMenuSub key={source}>
            <DropdownMenuSubTrigger className="capitalize">
              {source}
            </DropdownMenuSubTrigger>
            <DropdownMenuSubContent>
              {acronyms.map((acronym) => (
                <DropdownMenuItem
                  key={`${source}-${acronym}`}
                  onClick={() => onSelect(source, acronym)}
                >
                  {acronym}
                </DropdownMenuItem>
              ))}
            </DropdownMenuSubContent>
          </DropdownMenuSub>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  );
};

================
File: components/ContentRenderer.tsx
================
import React from "react";

export const ContentRenderer = ({ content }: { content: string }) => {
  // Remove extra spaces and newlines between tags
  const cleanContent = content
    .replace(/>\s+</g, "><")
    .replace(/\s+/g, " ")
    .trim();

  // Safely render the HTML content
  const createMarkup = () => ({ __html: cleanContent });

  return (
    <div className="text-gray-700" dangerouslySetInnerHTML={createMarkup()} />
  );
};

================
File: components/GenerateCitations.tsx
================
export const GenerateCitations = ({
  citationsArray,
}: {
  citationsArray?: { citation: string; link: string }[];
}) => {
  return (
    citationsArray && (
      <ol className="list-decimal pl-4 space-y-2">
        {citationsArray.map((item, index) => (
          <li key={index} className="text-gray-700">
            {item.citation}{" "}
            <a
              href={item.link}
              target="_blank"
              rel="noopener noreferrer"
              className="text-blue-600 hover:underline"
            >
              {item.link}
            </a>
            .
          </li>
        ))}
      </ol>
    )
  );
};

================
File: components/Omnipedia.tsx
================
"use client";

import React, { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { ChevronDown, ChevronUp } from "lucide-react";
import { SectionFeedback } from "@/components/SectionFeedback";
import { RequirementsSidebar } from "@/components/RequirementsSidebar";
import { requirementsData } from "@/lib/data";
import { GenerateCitations } from "./GenerateCitations";
import useSWR from "swr";
import { ArticleSelector } from "./ArticleSelector";
import {
  ArticleSection,
  SectionState,
  CategoryScore,
  Feedback,
  RequirementClassification,
  RequirementEvaluation,
} from "@/lib/types";
import { ContentRenderer } from "./ContentRenderer";

interface SelectedRequirement {
  id: string;
  category: string;
}

interface FilterHistoryEntry {
  searchQuery: string;
  classification: RequirementClassification | null;
  lastUsed: Date;
}

const MainContent = () => {
  // Core state
  const [selectedPath, setSelectedPath] = useState("");
  const [article, setArticle] = useState<ArticleSection[]>([]);
  const [evaluation, setEvaluation] = useState<ArticleSection[]>([]);
  const [selectedSection, setSelectedSection] = useState<string | null>(null);
  const [feedback, setFeedback] = useState<Feedback>();
  console.log("SELECTED: ", selectedSection);
  // Enhanced state
  const [selectedRequirements, setSelectedRequirements] = useState<
    SelectedRequirement[]
  >([]);
  const [sectionStates, setSectionStates] = useState<
    Record<string, SectionState>
  >({});
  const [categoryScores, setCategoryScores] = useState<
    Record<string, CategoryScore>
  >({});
  const [filterHistory, setFilterHistory] = useState<FilterHistoryEntry[]>([]);

  const fetcher = (url: string) => fetch(url).then((res) => res.json());

  const { data: evaluationData, error: evaluationError } = useSWR(
    selectedPath
      ? `/api/evaluation?path=${encodeURIComponent(selectedPath)}`
      : null,
    fetcher
  );

  const { data: articleData, error: articleError } = useSWR(
    selectedPath
      ? `/api/articles?path=${encodeURIComponent(selectedPath)}`
      : null,
    fetcher
  );

  // Section state management
  const toggleSection = (title: string) => {
    setSectionStates((prev) => ({
      ...prev,
      [title]: {
        isExpanded: !prev[title]?.isExpanded,
        lastViewed: new Date(),
        scores: prev[title]?.scores || {},
      },
    }));
    setSelectedSection((prev) => (prev === title ? null : title));
  };

  // Requirement selection management
  const toggleRequirement = (id: string, category: string) => {
    setSelectedRequirements((prev) => {
      const exists = prev.find((req) => req.id === id);
      if (exists) {
        return prev.filter((req) => req.id !== id);
      }
      return [...prev, { id, category }];
    });
  };

  // Score management with caching
  const updateCategoryScore = (
    category: string,
    evaluations: RequirementEvaluation[]
  ) => {
    const currentTime = new Date();
    const cached = categoryScores[category];

    if (
      cached &&
      currentTime.getTime() - cached.lastCalculated.getTime() < 5000
    ) {
      return cached.score;
    }

    const score =
      evaluations.reduce((acc, evaluation) => acc + evaluation.score, 0) /
      evaluations.length;

    setCategoryScores((prev) => ({
      ...prev,
      [category]: {
        score,
        lastCalculated: currentTime,
        evaluations,
      },
    }));

    return score;
  };

  // Data initialization and updates
  useEffect(() => {
    if (evaluationData?.data) {
      // Add the optional chaining here
      const { data } = evaluationData;
      setEvaluation(data);

      // Initialize or update section states
      const newSectionStates: Record<string, SectionState> = {};
      data.forEach((section: ArticleSection) => {
        newSectionStates[section.title] = {
          isExpanded: sectionStates[section.title]?.isExpanded || false,
          lastViewed: new Date(),
          scores: sectionStates[section.title]?.scores || {},
        };
      });
      setSectionStates(newSectionStates);
    }
  }, [evaluationData]);

  useEffect(() => {
    if (articleData?.data) {
      // Add the same check here for consistency
      const { data } = articleData;
      setArticle(data);
    }
  }, [articleData]);

  useEffect(() => {
    if (articleData) {
      const { data } = articleData;
      setArticle(data);
    }
  }, [articleData]);

  // Feedback updates
  useEffect(() => {
    if (selectedSection && evaluation) {
      const section = evaluation.find(
        (item) => item?.title === selectedSection
      );
      if (section) {
        setFeedback(section.feedback);
      }
    }
  }, [selectedSection, evaluation]);

  const handleArticleSelect = (source: string, acronym: string) => {
    const newPath = `${source}/${acronym}`;
    setSelectedPath(newPath);
    // Preserve states but clear current section
    setSelectedSection(null);
    setFeedback(undefined);
  };

  const handleFilterChange = (
    searchQuery: string,
    classification: RequirementClassification | null
  ) => {
    setFilterHistory((prev) => [
      {
        searchQuery,
        classification,
        lastUsed: new Date(),
      },
      ...prev.slice(0, 9), // Keep last 10 filters
    ]);
  };

  if (selectedPath && (!articleData || !evaluationData)) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="text-center">
          <span className="loading loading-spinner"></span>
          <p>Loading...</p>
        </div>
      </div>
    );
  }

  if (articleError || evaluationError) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="text-center text-red-500">
          <p>Error loading data</p>
        </div>
      </div>
    );
  }

  return (
    <ScrollArea className="h-auto w-full max-w-6xl mx-auto p-4 overflow-hidden">
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle className="text-3xl">
              {(article && article[0]?.title) || "Select an Article"}
            </CardTitle>
            <ArticleSelector onSelect={handleArticleSelect} />
          </div>
        </CardHeader>
      </Card>

      {article &&
        article.map((section, index) =>
          section.content !== "" ||
          (section.citations && section.citations.length > 0) ? (
            <Card
              key={index}
              className={`mb-2 ${
                selectedRequirements.some((req) =>
                  section.content.toLowerCase().includes(req.id.toLowerCase())
                )
                  ? "ring-2 ring-blue-500"
                  : ""
              }`}
            >
              <CardHeader
                className="flex flex-row items-center justify-between cursor-pointer"
                onClick={() => toggleSection(section.title)}
              >
                <CardTitle>{section.title}</CardTitle>
                {sectionStates[section.title]?.isExpanded ? (
                  <ChevronUp className="h-6 w-6" />
                ) : (
                  <ChevronDown className="h-6 w-6" />
                )}
              </CardHeader>
              <CardContent className="pb-0">
                <div>
                  {section.content && section.content.trim() !== "" && (
                    <ContentRenderer content={section.content} />
                  )}
                  {section.citations && section.citations.length > 0 && (
                    <GenerateCitations citationsArray={section.citations} />
                  )}
                </div>
                {selectedSection === section.title && feedback && (
                  <SectionFeedback
                    feedback={feedback}
                    sectionState={sectionStates[section.title]}
                    selectedRequirements={
                      new Set(selectedRequirements.map((r) => r.id))
                    }
                    onRequirementSelect={toggleRequirement}
                    onScoreUpdate={(category, score) => {
                      setSectionStates((prev) => ({
                        ...prev,
                        [section.title]: {
                          ...prev[section.title],
                          scores: {
                            ...prev[section.title].scores,
                            [category]: score,
                          },
                        },
                      }));
                    }}
                  />
                )}
              </CardContent>
            </Card>
          ) : null
        )}
    </ScrollArea>
  );
};

export const Omnipedia = () => {
  return (
    <div className="flex h-screen">
      <RequirementsSidebar groups={requirementsData.groups} />
      <main className="flex-1 overflow-auto mt-8">
        <MainContent />
      </main>
    </div>
  );
};

================
File: components/RequirementsSidebar.tsx
================
import React, { useState, useMemo } from "react";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import {
  HoverCard,
  HoverCardContent,
  HoverCardTrigger,
} from "@/components/ui/hover-card";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Search, MapPin, Clock, Info } from "lucide-react";

// Classification types
export type RequirementClassification =
  | "Imperative Standards"
  | "Best Practices"
  | "Flexible Guidelines"
  | "Contextual Considerations";

// Single requirement
export interface Requirement {
  id: string;
  description: string;
  reference?: string;
  classification: RequirementClassification;
  where: string;
  when: string;
}

// Group of requirements
export interface RequirementGroup {
  description: string;
  requirements: Requirement[];
}

// Full requirements index
export interface RequirementsIndex {
  groups: {
    [key: string]: RequirementGroup;
  };
}

// Props for the sidebar component
export interface RequirementsSidebarProps {
  groups: RequirementsIndex["groups"];
}

// Props for the requirement component
export interface RequirementProps {
  requirement: Requirement;
}

// Classification badge variants
const getClassificationBadge = (classification: string) => {
  switch (classification) {
    case "Imperative Standards":
      return <Badge variant="destructive">Imperative</Badge>;
    case "Best Practices":
      return <Badge variant="secondary">Best Practice</Badge>;
    case "Flexible Guidelines":
      return <Badge variant="outline">Flexible</Badge>;
    case "Contextual Considerations":
      return <Badge>Contextual</Badge>;
    default:
      return <Badge variant="outline">{classification}</Badge>;
  }
};

const Requirement = ({ requirement }: RequirementProps) => (
  <HoverCard>
    <HoverCardTrigger asChild>
      <div className="flex items-center gap-2 p-2 rounded hover:bg-gray-100 cursor-pointer group">
        <div className="w-8 text-sm font-medium text-gray-500">
          {requirement.id}
        </div>
        <div className="flex-1 text-sm group-hover:text-gray-900">
          {requirement.description}
        </div>
        {getClassificationBadge(requirement.classification)}
      </div>
    </HoverCardTrigger>
    <HoverCardContent className="w-80">
      <div className="space-y-3">
        <div>
          <h4 className="font-medium flex items-center gap-2">
            {requirement.id}
            {getClassificationBadge(requirement.classification)}
          </h4>
          <p className="text-sm text-gray-600 mt-1">
            {requirement.description}
          </p>
        </div>

        <Separator />

        <div className="space-y-2">
          <div className="flex items-center gap-2 text-sm">
            <MapPin className="h-4 w-4 text-gray-500" />
            <span>{requirement.where}</span>
          </div>
          <div className="flex items-center gap-2 text-sm">
            <Clock className="h-4 w-4 text-gray-500" />
            <span>{requirement.when}</span>
          </div>
        </div>

        {requirement.reference && (
          <div className="pt-2">
            <p className="text-xs text-gray-500 italic">
              "{requirement.reference}"
            </p>
          </div>
        )}
      </div>
    </HoverCardContent>
  </HoverCard>
);

export const RequirementsSidebar = ({ groups }: RequirementsSidebarProps) => {
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedClassification, setSelectedClassification] = useState<
    string | null
  >(null);

  // Search function
  const filteredGroups = useMemo<RequirementsIndex["groups"]>(() => {
    const searchLower = searchQuery.toLowerCase();

    return Object.entries(groups).reduce<RequirementsIndex["groups"]>(
      (acc, [groupName, requirements]) => {
        const filteredRequirements = requirements.filter((req) => {
          // Filter by classification if selected
          if (
            selectedClassification &&
            req.classification !== selectedClassification
          ) {
            return false;
          }

          // Search across all fields
          return (
            req.id.toLowerCase().includes(searchLower) ||
            req.description.toLowerCase().includes(searchLower) ||
            req.where.toLowerCase().includes(searchLower) ||
            req.when.toLowerCase().includes(searchLower) ||
            (req.reference &&
              req.reference.toLowerCase().includes(searchLower)) ||
            req.classification.toLowerCase().includes(searchLower)
          );
        });

        if (filteredRequirements.length > 0) {
          acc[groupName] = filteredRequirements;
        }

        return acc;
      },
      {}
    );
  }, [groups, searchQuery, selectedClassification]);

  const classifications = useMemo(
    () =>
      Array.from(
        new Set(
          Object.values(groups)
            .flatMap((requirements) => requirements)
            .map((req) => req.classification)
        )
      ),
    [groups]
  );

  return (
    <div className="w-80 h-screen border-r bg-gray-50 flex flex-col">
      {/* Info Header */}
      <div className="p-4 bg-white border-b">
        <Alert>
          <Info className="h-4 w-4" />
          <AlertTitle>Requirements Index</AlertTitle>
          <AlertDescription className="text-xs text-gray-600">
            Browse and search content requirements by category, classification,
            or keyword.
          </AlertDescription>
        </Alert>
      </div>

      {/* Search and Filters */}
      <div className="p-4 border-b bg-white space-y-4">
        <div className="relative">
          <Search className="absolute left-2 top-2.5 h-4 w-4 text-gray-500" />
          <Input
            placeholder="Search requirements..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-8"
          />
        </div>

        <div className="flex flex-wrap gap-2">
          <Button
            variant={!selectedClassification ? "secondary" : "outline"}
            size="sm"
            onClick={() => setSelectedClassification(null)}
          >
            All
          </Button>
          {classifications.map((classification) => (
            <Button
              key={classification}
              variant={
                selectedClassification === classification
                  ? "secondary"
                  : "outline"
              }
              size="sm"
              onClick={() => setSelectedClassification(classification)}
            >
              {classification.split(" ")[0]}
            </Button>
          ))}
        </div>
      </div>

      {/* Requirements List */}
      <ScrollArea className="flex-1">
        <div className="p-4">
          <Accordion type="multiple" className="space-y-2">
            {Object.entries(filteredGroups).map(([groupName, requirements]) => (
              <AccordionItem key={groupName} value={groupName}>
                <AccordionTrigger className="hover:no-underline">
                  <div className="flex items-center gap-2">
                    <span>{groupName}</span>
                    <Badge variant="secondary">{requirements.length}</Badge>
                  </div>
                </AccordionTrigger>
                <AccordionContent>
                  <div className="mt-2">
                    {requirements.map((req) => (
                      <Requirement key={req.id} requirement={req} />
                    ))}
                  </div>
                </AccordionContent>
              </AccordionItem>
            ))}
          </Accordion>
        </div>
      </ScrollArea>

      {/* Stats Footer */}
      <div className="p-4 border-t bg-white">
        <div className="flex justify-between text-sm text-gray-600">
          <span>
            {Object.values(filteredGroups).reduce(
              (acc, requirements) => acc + requirements.length,
              0
            )}{" "}
            requirements
          </span>
          <span>{Object.keys(filteredGroups).length} groups</span>
        </div>
      </div>
    </div>
  );
};

================
File: components/SectionFeedback.tsx
================
import React from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "./ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { AlertCircle, CheckCircle, Info, HelpCircle } from "lucide-react";
import { requirementsData } from "@/lib/data";
import {
  CategoryScore,
  Feedback,
  RequirementEvaluation,
  SectionState,
} from "@/lib/types";

interface SectionFeedbackProps {
  feedback: Feedback;
  sectionState: SectionState;
  onRequirementSelect: (requirementId: string, category: string) => void;
  selectedRequirements: Set<string>;
  onScoreUpdate: (category: string, score: CategoryScore) => void;
}

export const SectionFeedback: React.FC<SectionFeedbackProps> = ({
  feedback,
  sectionState,
  onRequirementSelect,
  selectedRequirements,
  onScoreUpdate,
}) => {
  const calculateCategoryScore = (
    category: string,
    evaluations: RequirementEvaluation[]
  ) => {
    // Check if we have a cached score that's less than 5 seconds old
    const cachedScore = sectionState.scores[category];
    if (
      cachedScore &&
      new Date().getTime() - cachedScore.lastCalculated.getTime() < 5000
    ) {
      return cachedScore.score;
    }

    // Calculate new score
    if (!evaluations.length) return 0;
    const scores = evaluations.map((req) => req.score);
    const average = scores.reduce((acc, curr) => acc + curr, 0) / scores.length;

    // Cache the new score
    const newScore = {
      score: average,
      lastCalculated: new Date(),
      evaluations,
    };
    onScoreUpdate(category, newScore);

    return average;
  };

  const getScoreBadgeVariant = (score: number) => {
    if (score >= 0.8) return "secondary";
    if (score >= 0.6) return "outline";
    return "destructive";
  };

  if (!feedback) return null;

  return (
    <Card className="w-full">
      <CardHeader>
        <CardTitle className="flex items-center justify-between">
          Section Feedback
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger>
                <HelpCircle className="h-5 w-5 text-gray-400" />
              </TooltipTrigger>
              <TooltipContent>
                <p>Detailed feedback for each category and requirement</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </CardTitle>
        <CardDescription>
          Analysis of content requirements and guidelines
        </CardDescription>
      </CardHeader>

      <CardContent className="mb-0">
        <Tabs defaultValue="infoboxes" className="w-full">
          <TabsList className="w-full">
            {Object.entries(feedback)
              .sort(([a], [b]) => a.localeCompare(b))
              .map(([category, categoryData]) => {
                const evaluationCount = categoryData.reduce(
                  (acc, section) =>
                    acc + section.requirement_evaluations.length,
                  0
                );

                return (
                  <TabsTrigger
                    key={category}
                    value={category.toLowerCase()}
                    className="flex items-center gap-2"
                  >
                    {category}
                    <Badge
                      variant="secondary"
                      className="h-5 w-5 flex items-center justify-center rounded-full"
                    >
                      {evaluationCount}
                    </Badge>
                  </TabsTrigger>
                );
              })}
          </TabsList>

          {Object.entries(feedback).map(([category, categoryData]) => (
            <TabsContent key={category} value={category.toLowerCase()}>
              <ScrollArea className="h-[calc(100vh-300px)] min-h-[400px] max-h-[600px] pr-4">
                {categoryData.map((section, sectionIndex) => (
                  <div key={sectionIndex} className="mb-6">
                    {section.meta_notes && (
                      <Alert className="mb-4">
                        <Info className="h-4 w-4" />
                        <AlertTitle>Meta Notes</AlertTitle>
                        <AlertDescription>
                          {section.meta_notes}
                        </AlertDescription>
                      </Alert>
                    )}

                    {section.requirement_evaluations.length > 0 && (
                      <div className="mb-4">
                        <Alert>
                          <AlertCircle className="h-4 w-4" />
                          <AlertTitle>Category Score</AlertTitle>
                          <AlertDescription className="mt-2">
                            <Progress
                              value={
                                calculateCategoryScore(
                                  category,
                                  section.requirement_evaluations
                                ) * 100
                              }
                              className="h-2"
                            />
                            <span className="text-sm text-gray-500 mt-1 block">
                              {(
                                calculateCategoryScore(
                                  category,
                                  section.requirement_evaluations
                                ) * 100
                              ).toFixed(1)}
                              % compliance
                            </span>
                          </AlertDescription>
                        </Alert>
                      </div>
                    )}

                    <Accordion type="single" collapsible className="w-full">
                      {section.requirement_evaluations.map((req, index) => (
                        <AccordionItem
                          key={index}
                          value={`item-${index}`}
                          className={
                            selectedRequirements.has(req.requirement_id)
                              ? "ring-2 ring-blue-500"
                              : ""
                          }
                          onClick={() =>
                            onRequirementSelect(req.requirement_id, category)
                          }
                        >
                          <AccordionTrigger className="hover:no-underline">
                            <div className="flex items-center gap-2">
                              {req.score === 1.0 ? (
                                <CheckCircle className="h-4 w-4 text-green-500" />
                              ) : req.score === 0.0 ? (
                                <AlertCircle className="h-4 w-4 text-red-500" />
                              ) : (
                                <Info className="h-4 w-4 text-yellow-500" />
                              )}
                              <span>Requirement {req.requirement_id}</span>
                              <Badge variant={getScoreBadgeVariant(req.score)}>
                                {(req.score * 100).toFixed(0)}%
                              </Badge>
                              <Badge variant="outline">
                                Confidence: {(req.confidence * 100).toFixed(0)}%
                              </Badge>
                            </div>
                          </AccordionTrigger>
                          <AccordionContent>
                            <div className="space-y-4 p-4">
                              <div className="space-y-2">
                                <h4 className="font-medium">Applicability</h4>
                                <p className="text-sm text-gray-600">
                                  {req.applicability_reasoning}
                                </p>
                              </div>

                              <div className="space-y-2">
                                <h4 className="font-medium">Evidence</h4>
                                <p className="text-sm text-gray-600">
                                  {req.evidence}
                                </p>
                              </div>

                              <div className="space-y-2">
                                <h4 className="font-medium">Reasoning</h4>
                                <p className="text-sm text-gray-600">
                                  {req.reasoning}
                                </p>
                              </div>

                              {req.overlap_notes &&
                                req.overlap_notes !== "N/A" && (
                                  <div className="space-y-2">
                                    <h4 className="font-medium">
                                      Overlap Notes
                                    </h4>
                                    <p className="text-sm text-gray-600">
                                      {req.overlap_notes}
                                    </p>
                                  </div>
                                )}
                            </div>
                          </AccordionContent>
                        </AccordionItem>
                      ))}
                    </Accordion>
                  </div>
                ))}
              </ScrollArea>
            </TabsContent>
          ))}
        </Tabs>
      </CardContent>
    </Card>
  );
};

================
File: lib/data.ts
================
import { RequirementsIndex } from "./types";

export const requirementsData: RequirementsIndex = {
  groups: {
    Content: [
      {
        id: "R1",
        description: "Do not hype a study by listing authors' qualifications.",
        reference:
          "In general, do not hype a study by listing the names, credentials, institutions, or other 'qualifications' of their authors.",
        category: "Content",
        classification: "Imperative Standards",
        where: "Article sections discussing studies",
        when: "Always",
      },
      {
        id: "R2",
        description:
          "Focus article prose on what a cited study says about the gene or protein.",
        reference:
          "Article prose should focus on what a cited study says about the structure, function, clinical significance, etc. of the gene or protein, not what the gene or protein says about a particular study or the research group who conducted that study.",
        category: "Content",
        classification: "Imperative Standards",
        where: "Main content sections",
        when: "Always",
      },
      {
        id: "R3",
        description:
          "Mention notable contributions and discoveries in the history section.",
        reference:
          "Particularly notable contributions along with who made the discovery however should be mentioned in the discovery/history section.",
        category: "Content",
        classification: "Best Practices",
        where: "History/Discovery section",
        when: "When notable contributions exist",
      },
      {
        id: "R4",
        description:
          "Use the recommended UniProt protein name as the article name if it is relatively short.",
        reference:
          "If relatively short, the recommended UniProt protein name should be used as the article name.",
        category: "Content",
        classification: "Imperative Standards",
        where: "Article title",
        when: "When the UniProt name is relatively short",
      },
      {
        id: "R5",
        description:
          "Use a protein acronym or official HUGO gene symbol with '(gene)' if the protein name is verbose.",
        reference:
          "If the protein name is verbose, either a widely used protein acronym or the official HUGO gene symbol, followed by '(gene)' if necessary to disambiguate.",
        category: "Content",
        classification: "Imperative Standards",
        where: "Article title",
        when: "When the UniProt name is verbose",
      },
      {
        id: "R6",
        description:
          "Include the taxon in the title for viral protein articles.",
        reference:
          "If the article is about a viral protein, it is recommended to include the taxon in the title.",
        category: "Content",
        classification: "Best Practices",
        where: "Article title",
        when: "For viral protein articles",
      },
      {
        id: "R7",
        description:
          "Do not consider parenthesized disambiguation as unnecessary.",
        reference:
          "A parenthesized term added to disambiguate common symbols does not constitute unnecessary disambiguation even when it is the only article with such a name.",
        category: "Content",
        classification: "Best Practices",
        where: "Article title",
        when: "When disambiguating common symbols",
      },
      {
        id: "R8",
        description:
          "Use HUGO Gene Nomenclature Committee abbreviations in italic font.",
        reference:
          "The abbreviations of genes are according to HUGO Gene Nomenclature Committee and written in ''italic'' font style.",
        category: "Language Usage",
        classification: "Imperative Standards",
        where: "Gene nomenclature in text",
        when: "Always when mentioning gene abbreviations",
      },
      {
        id: "R9",
        description: "Prefer abbreviations over full gene names.",
        reference:
          "It is recommended that abbreviations instead of the full name are used.",
        category: "Language Usage",
        classification: "Best Practices",
        where: "Throughout the article",
        when: "When referring to genes",
      },
      {
        id: "R10",
        description: "Write human gene names in all capitals.",
        reference:
          "Human gene names are written in capitals, for example 'ALDOA', 'INS', etc.",
        category: "Language Usage",
        classification: "Imperative Standards",
        where: "Gene names in text",
        when: "Always for human genes",
      },
      {
        id: "R11",
        description:
          "Capitalize only the initial letter for orthologs in other species.",
        reference:
          "For orthologs of human genes in other species, only the initial letter is capitalised, for example mouse 'Aldoa', bovine 'Ins', etc.",
        category: "Language Usage",
        classification: "Imperative Standards",
        where: "Gene names in text",
        when: "When referring to orthologs in other species",
      },
      {
        id: "R12",
        description: "Use recommended usages for gene symbols.",
        reference:
          "The following usages of gene symbols are recommended: the ALDOA gene is regulated..., the rat gene for Aldoa is regulated... or ''ALDOA'' is regulated...",
        category: "Language Usage",
        classification: "Best Practices",
        where: "Narrative text",
        when: "When referring to gene regulation",
      },
      {
        id: "R13",
        description: "Avoid using redundant phrasing for gene symbols.",
        reference: "the gene ''ALDOA'' is regulated since it is redundant.",
        category: "Language Usage",
        classification: "Best Practices",
        where: "Narrative text",
        when: "When referring to gene regulation",
      },
      {
        id: "R14",
        description: "Maintain standard format for diagrams where possible.",
        reference: "Where possible, diagrams should keep to a standard format.",
        category: "Formatting",
        classification: "Imperative Standards",
        where: "Images and diagrams",
        when: "Always when including diagrams",
      },
      {
        id: "R15",
        description:
          "Suggest expansions to standardized formatting if diagram guide is insufficient.",
        reference:
          "If the diagram guide does not give sufficient guidance on the style for the images in an article, consider suggesting expansions to the standardised formatting.",
        category: "Formatting",
        classification: "Best Practices",
        where: "Images and diagrams",
        when: "When existing guidelines are insufficient",
      },
      {
        id: "R16",
        description:
          "Include one or more appropriate infoboxes at the top of each article.",
        reference:
          "One or more of the following infoboxes as appropriate should be included at the top of each article:",
        category: "Infoboxes",
        classification: "Imperative Standards",
        where: "Top of the article",
        when: "Always when applicable",
      },
      {
        id: "R17",
        description:
          "Add enzyme infobox if only one human paralog is assigned to an EC number.",
        reference:
          "If there is only one human paralog assigned to a given EC number..., then in addition to a protein infobox, it may be appropriate to also add the corresponding enzyme infobox.",
        category: "Infoboxes",
        classification: "Best Practices",
        where: "Top of the article",
        when: "When one human paralog is assigned to an EC number",
      },
      {
        id: "R18",
        description:
          "Include a protein family infobox if only one human paralog is assigned to a Pfam family.",
        reference:
          "Likewise, if there is only one human paralog that has been assigned to Pfam family, then including a protein family infobox may also be appropriate.",
        category: "Infoboxes",
        classification: "Best Practices",
        where: "Top of the article",
        when: "When one human paralog is assigned to a Pfam family",
      },
      {
        id: "R19",
        description:
          "Limit the number of infoboxes and place less useful ones in a table section at the end.",
        reference:
          "There exist some cases where a large number of infoboxes may apply to an article. You may put less useful ones in a section at the end, laid side-by-side with a table.",
        category: "Infoboxes",
        classification: "Best Practices",
        where: "End of the article",
        when: "When multiple infoboxes are applicable",
      },
      {
        id: "R20",
        description: "Include the lead section before the first headline.",
        reference:
          "The lead section is defined as 'the section before the first headline. The table of contents, if displayed, appears between the lead section and the first headline.'",
        category: "Structure",
        classification: "Imperative Standards",
        where: "Top of the article",
        when: "Always",
      },
      {
        id: "R21",
        description:
          "Define the scope of the article in the first sentence of the lead.",
        reference:
          "The first sentence of the lead should define what the scope of the article is.",
        category: "Structure",
        classification: "Imperative Standards",
        where: "First sentence of the lead",
        when: "Always",
      },
      {
        id: "R22",
        description:
          "Provide specific gene information without unnecessary repetition from the infobox.",
        reference:
          "Specific information about the gene... should not be unnecessarily repeated in this section unless especially notable.",
        category: "Content",
        classification: "Imperative Standards",
        where: "Gene section",
        when: "When information is already in the infobox",
      },
      {
        id: "R23",
        description:
          "Provide specific protein information without unnecessary repetition from the infobox.",
        reference:
          "Specific information about the protein... should not be unnecessarily repeated unless especially notable.",
        category: "Content",
        classification: "Imperative Standards",
        where: "Protein section",
        when: "When information is already in the infobox",
      },
      {
        id: "R24",
        description:
          "Include 'Species, tissue, and subcellular distribution' as an optional section.",
        reference:
          "Optional section that concisely describes what species this gene is expressed..., what tissue the protein is expressed, and which subcellular compartments or organelles the protein is found...",
        category: "Structure",
        classification: "Flexible Guidelines",
        where: "Content section",
        when: "When relevant information is available",
      },
      {
        id: "R25",
        description:
          "Include a 'Function' section to describe the protein's function.",
        reference: "Describe the function of the transcribed protein.",
        category: "Content",
        classification: "Imperative Standards",
        where: "Content section",
        when: "Always",
      },
      {
        id: "R26",
        description:
          "Include 'Interactions' as an optional section listing protein interactions.",
        reference:
          "Optional section that lists proteins that the protein that is the subject of the article is known to interact with.",
        category: "Structure",
        classification: "Flexible Guidelines",
        where: "Content section",
        when: "When interaction information is available",
      },
      {
        id: "R27",
        description:
          "Include 'Clinical significance' section listing related diseases or conditions.",
        reference:
          "List diseases or conditions that are a result of a mutation in the gene or a deficiency or excess of the expressed protein.",
        category: "Content",
        classification: "Imperative Standards",
        where: "Clinical significance section",
        when: "When applicable",
      },
      {
        id: "R28",
        description:
          "Do not mention research groups or institutions directly in the article text.",
        reference:
          "In general, it is not appropriate to mention the research group or institution that conducted a study directly in the text of the article.",
        category: "Content",
        classification: "Imperative Standards",
        where: "Narrative text",
        when: "Always",
      },
      {
        id: "R29",
        description: "List names of key discoverers in the history section.",
        reference:
          "However it is appropriate to list the names of those who made key discoveries concerning the gene or protein in this section.",
        category: "Content",
        classification: "Imperative Standards",
        where: "History/Discovery section",
        when: "When key discoveries exist",
      },
      {
        id: "R30",
        description:
          "Link the article to the appropriate Wikidata item based on the first sentence of the lead.",
        reference:
          "The Wikipedia article should be linked to a Wikidata item of the entity first mentioned in the first sentence of the lead section...",
        category: "Citations",
        classification: "Imperative Standards",
        where: "Wikidata linkage",
        when: "Always",
      },
      {
        id: "R31",
        description:
          "Use inline citations densely with <ref> tags or parenthetical citations.",
        reference:
          "MCB articles should be relatively dense with inline citations, using either <ref> tags (footnotes) or parenthetical citations.",
        category: "Citations",
        classification: "Imperative Standards",
        where: "Throughout the article",
        when: "Always",
      },
      {
        id: "R32",
        description:
          "Do not use non-specific general references in the References section.",
        reference:
          "It is not acceptable to write substantial amounts of prose and then add your textbook to the References section as a non-specific or general reference.",
        category: "Citations",
        classification: "Imperative Standards",
        where: "References section",
        when: "Always",
      },
      {
        id: "R33",
        description:
          "Maintain consistent citation formatting within an article.",
        reference:
          "There is no standard for formatting citations on Wikipedia, but the format should be consistent within any one article.",
        category: "Citations",
        classification: "Imperative Standards",
        where: "Throughout the article",
        when: "Always",
      },
      {
        id: "R34",
        description:
          "Prefer using citation templates for better control over presentation.",
        reference:
          "Some editors prefer to use citation templates such as {{Cite journal}}, {{Cite book}}, etc.",
        category: "Citations",
        classification: "Best Practices",
        where: "Throughout the article",
        when: "When formatting citations",
      },
      {
        id: "R35",
        description: "Supply hyperlinks in citations when available.",
        reference:
          "In addition to the standard citation text, it is useful to supply hyperlinks...",
        category: "Citations",
        classification: "Best Practices",
        where: "In citation templates",
        when: "When hyperlinks are available",
      },
      {
        id: "R36",
        description:
          "Avoid adding 'Retrieved on' dates for convenience links to online journals.",
        reference:
          "Do not add a 'Retrieved on' date for convenience links to online editions of paper journals...",
        category: "Citations",
        classification: "Imperative Standards",
        where: "In citation templates",
        when: "When linking to online editions of paper journals",
      },
      {
        id: "R37",
        description:
          "Link articles about related proteins using navigation boxes.",
        reference:
          "Articles about related proteins may be cross linked by including one or more navigation boxes as appropriate.",
        category: "Structure",
        classification: "Best Practices",
        where: "End of the article",
        when: "When articles are related",
      },
      {
        id: "R38",
        description: "Add each article to at least one appropriate category.",
        reference:
          "Every Wikipedia article should be added to at least one category.",
        category: "Structure",
        classification: "Imperative Standards",
        where: "Article metadata",
        when: "Always",
      },
    ],
    Formatting: [
      {
        id: "R14",
        description: "Maintain standard format for diagrams where possible.",
        reference: "Where possible, diagrams should keep to a standard format.",
        category: "Formatting",
        classification: "Imperative Standards",
        where: "Images and diagrams",
        when: "Always when including diagrams",
      },
      {
        id: "R15",
        description:
          "Suggest expansions to standardized formatting if diagram guide is insufficient.",
        reference:
          "If the diagram guide does not give sufficient guidance on the style for the images in an article, consider suggesting expansions to the standardised formatting.",
        category: "Formatting",
        classification: "Best Practices",
        where: "Images and diagrams",
        when: "When existing guidelines are insufficient",
      },
    ],
    Infoboxes: [
      {
        id: "R16",
        description:
          "Include one or more appropriate infoboxes at the top of each article.",
        reference:
          "One or more of the following infoboxes as appropriate should be included at the top of each article:",
        category: "Infoboxes",
        classification: "Imperative Standards",
        where: "Top of the article",
        when: "Always when applicable",
      },
      {
        id: "R17",
        description:
          "Add enzyme infobox if only one human paralog is assigned to an EC number.",
        reference:
          "If there is only one human paralog assigned to a given EC number..., then in addition to a protein infobox, it may be appropriate to also add the corresponding enzyme infobox.",
        category: "Infoboxes",
        classification: "Best Practices",
        where: "Top of the article",
        when: "When one human paralog is assigned to an EC number",
      },
      {
        id: "R18",
        description:
          "Include a protein family infobox if only one human paralog is assigned to a Pfam family.",
        reference:
          "Likewise, if there is only one human paralog that has been assigned to Pfam family, then including a protein family infobox may also be appropriate.",
        category: "Infoboxes",
        classification: "Best Practices",
        where: "Top of the article",
        when: "When one human paralog is assigned to a Pfam family",
      },
      {
        id: "R19",
        description:
          "Limit the number of infoboxes and place less useful ones in a table section at the end.",
        reference:
          "There exist some cases where a large number of infoboxes may apply to an article. You may put less useful ones in a section at the end, laid side-by-side with a table.",
        category: "Infoboxes",
        classification: "Best Practices",
        where: "End of the article",
        when: "When multiple infoboxes are applicable",
      },
    ],
    "Language Usage": [
      {
        id: "R8",
        description:
          "Use HUGO Gene Nomenclature Committee abbreviations in italic font.",
        reference:
          "The abbreviations of genes are according to HUGO Gene Nomenclature Committee and written in ''italic'' font style.",
        category: "Language Usage",
        classification: "Imperative Standards",
        where: "Gene nomenclature in text",
        when: "Always when mentioning gene abbreviations",
      },
      {
        id: "R9",
        description: "Prefer abbreviations over full gene names.",
        reference:
          "It is recommended that abbreviations instead of the full name are used.",
        category: "Language Usage",
        classification: "Best Practices",
        where: "Throughout the article",
        when: "When referring to genes",
      },
      {
        id: "R10",
        description: "Write human gene names in all capitals.",
        reference:
          "Human gene names are written in capitals, for example 'ALDOA', 'INS', etc.",
        category: "Language Usage",
        classification: "Imperative Standards",
        where: "Gene names in text",
        when: "Always for human genes",
      },
      {
        id: "R11",
        description:
          "Capitalize only the initial letter for orthologs in other species.",
        reference:
          "For orthologs of human genes in other species, only the initial letter is capitalised, for example mouse 'Aldoa', bovine 'Ins', etc.",
        category: "Language Usage",
        classification: "Imperative Standards",
        where: "Gene names in text",
        when: "When referring to orthologs in other species",
      },
      {
        id: "R12",
        description: "Use recommended usages for gene symbols.",
        reference:
          "The following usages of gene symbols are recommended: the ALDOA gene is regulated..., the rat gene for Aldoa is regulated... or ''ALDOA'' is regulated...",
        category: "Language Usage",
        classification: "Best Practices",
        where: "Narrative text",
        when: "When referring to gene regulation",
      },
      {
        id: "R13",
        description: "Avoid using redundant phrasing for gene symbols.",
        reference: "the gene ''ALDOA'' is regulated since it is redundant.",
        category: "Language Usage",
        classification: "Best Practices",
        where: "Narrative text",
        when: "When referring to gene regulation",
      },
    ],
    Citations: [
      {
        id: "R30",
        description:
          "Link the article to the appropriate Wikidata item based on the first sentence of the lead.",
        reference:
          "The Wikipedia article should be linked to a Wikidata item of the entity first mentioned in the first sentence of the lead section...",
        category: "Citations",
        classification: "Imperative Standards",
        where: "Wikidata linkage",
        when: "Always",
      },
      {
        id: "R31",
        description:
          "Use inline citations densely with <ref> tags or parenthetical citations.",
        reference:
          "MCB articles should be relatively dense with inline citations, using either <ref> tags (footnotes) or parenthetical citations.",
        category: "Citations",
        classification: "Imperative Standards",
        where: "Throughout the article",
        when: "Always",
      },
      {
        id: "R32",
        description:
          "Do not use non-specific general references in the References section.",
        reference:
          "It is not acceptable to write substantial amounts of prose and then add your textbook to the References section as a non-specific or general reference.",
        category: "Citations",
        classification: "Imperative Standards",
        where: "References section",
        when: "Always",
      },
      {
        id: "R33",
        description:
          "Maintain consistent citation formatting within an article.",
        reference:
          "There is no standard for formatting citations on Wikipedia, but the format should be consistent within any one article.",
        category: "Citations",
        classification: "Imperative Standards",
        where: "Throughout the article",
        when: "Always",
      },
      {
        id: "R34",
        description:
          "Prefer using citation templates for better control over presentation.",
        reference:
          "Some editors prefer to use citation templates such as {{Cite journal}}, {{Cite book}}, etc.",
        category: "Citations",
        classification: "Best Practices",
        where: "Throughout the article",
        when: "When formatting citations",
      },
      {
        id: "R35",
        description: "Supply hyperlinks in citations when available.",
        reference:
          "In addition to the standard citation text, it is useful to supply hyperlinks...",
        category: "Citations",
        classification: "Best Practices",
        where: "In citation templates",
        when: "When hyperlinks are available",
      },
      {
        id: "R36",
        description:
          "Avoid adding 'Retrieved on' dates for convenience links to online journals.",
        reference:
          "Do not add a 'Retrieved on' date for convenience links to online editions of paper journals...",
        category: "Citations",
        classification: "Imperative Standards",
        where: "In citation templates",
        when: "When linking to online editions of paper journals",
      },
    ],
    Structure: [
      {
        id: "R20",
        description: "Include the lead section before the first headline.",
        reference:
          "The lead section is defined as 'the section before the first headline. The table of contents, if displayed, appears between the lead section and the first headline.'",
        category: "Structure",
        classification: "Imperative Standards",
        where: "Top of the article",
        when: "Always",
      },
      {
        id: "R21",
        description:
          "Define the scope of the article in the first sentence of the lead.",
        reference:
          "The first sentence of the lead should define what the scope of the article is.",
        category: "Structure",
        classification: "Imperative Standards",
        where: "First sentence of the lead",
        when: "Always",
      },
      {
        id: "R24",
        description:
          "Include 'Species, tissue, and subcellular distribution' as an optional section.",
        reference:
          "Optional section that concisely describes what species this gene is expressed..., what tissue the protein is expressed, and which subcellular compartments or organelles the protein is found...",
        category: "Structure",
        classification: "Flexible Guidelines",
        where: "Content section",
        when: "When relevant information is available",
      },
      {
        id: "R25",
        description:
          "Include a 'Function' section to describe the protein's function.",
        reference: "Describe the function of the transcribed protein.",
        category: "Structure",
        classification: "Imperative Standards",
        where: "Content section",
        when: "Always",
      },
      {
        id: "R26",
        description:
          "Include 'Interactions' as an optional section listing protein interactions.",
        reference:
          "Optional section that lists proteins that the protein that is the subject of the article is known to interact with.",
        category: "Structure",
        classification: "Flexible Guidelines",
        where: "Content section",
        when: "When interaction information is available",
      },
      {
        id: "R27",
        description:
          "Include 'Clinical significance' section listing related diseases or conditions.",
        reference:
          "List diseases or conditions that are a result of a mutation in the gene or a deficiency or excess of the expressed protein.",
        category: "Structure",
        classification: "Imperative Standards",
        where: "Clinical significance section",
        when: "When applicable",
      },
      {
        id: "R28",
        description:
          "Do not mention research groups or institutions directly in the article text.",
        reference:
          "In general, it is not appropriate to mention the research group or institution that conducted a study directly in the text of the article.",
        category: "Structure",
        classification: "Imperative Standards",
        where: "Narrative text",
        when: "Always",
      },
      {
        id: "R29",
        description: "List names of key discoverers in the history section.",
        reference:
          "However it is appropriate to list the names of those who made key discoveries concerning the gene or protein in this section.",
        category: "Structure",
        classification: "Imperative Standards",
        where: "History/Discovery section",
        when: "When key discoveries exist",
      },
      {
        id: "R37",
        description:
          "Link articles about related proteins using navigation boxes.",
        reference:
          "Articles about related proteins may be cross linked by including one or more navigation boxes as appropriate.",
        category: "Structure",
        classification: "Best Practices",
        where: "End of the article",
        when: "When articles are related",
      },
      {
        id: "R38",
        description: "Add each article to at least one appropriate category.",
        reference:
          "Every Wikipedia article should be added to at least one category.",
        category: "Structure",
        classification: "Imperative Standards",
        where: "Article metadata",
        when: "Always",
      },
    ],
  },
} as const;

================
File: lib/json.ts
================
import fs from "fs/promises";
import path from "path";
import { marked } from "marked";
import { Section } from "./types";
import { processRefs } from "./utils";

const getDataFilePath = (
  type: "articles" | "results",
  filePath: string,
  extension: string
) => {
  // In development, use the local filesystem
  if (process.env.NODE_ENV === "development") {
    return path.join(
      process.cwd(),
      "public",
      "data",
      type,
      `${filePath}.${extension}`
    );
  }

  // In production (Vercel), use the public directory
  return path.join(
    process.cwd(),
    "public",
    "data",
    type,
    `${filePath}.${extension}`
  );
};

export async function getData(filePath: string): Promise<{ data: any | null }> {
  try {
    const fullPath = getDataFilePath("results", filePath, "json");
    const jsonData = await fs.readFile(fullPath, "utf8");
    return { data: JSON.parse(jsonData) };
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === "ENOENT") {
      return { data: null };
    }
    throw error;
  }
}

export async function parseWikicrow(
  filePath: string
): Promise<{ data: Section[] }> {
  const fullPath = getDataFilePath("articles", filePath, "md");
  const markdownText = await fs.readFile(fullPath, "utf-8");

  // Rest of the parseWikicrow function remains the same
  const tokens = marked.lexer(markdownText);
  const structuredData: Section[] = [];
  let currentHierarchy: string[] = [];
  let currentSection: Section | null = null;

  for (const token of tokens) {
    if (token.type === "heading") {
      if (currentSection) {
        structuredData.push(currentSection);
      }

      const level = token.depth;
      const title = token.text;

      currentHierarchy = [...currentHierarchy.slice(0, level - 1), title];
      currentSection = {
        title,
        content: "",
        hierarchy: currentHierarchy.join(" > "),
      };
    } else if (token.type === "paragraph" || token.type === "list") {
      if (currentSection) {
        currentSection.content += marked.parser([token]) + " ";
      }
    }
  }

  if (currentSection) {
    structuredData.push(currentSection);
  }

  return { data: structuredData };
}

export async function parseeWikicrow(
  filePath: string
): Promise<{ data: Section[] }> {
  const fullPath = getDataFilePath("articles", filePath, "md");
  const markdownText = await fs.readFile(fullPath, "utf-8");
  const lines = markdownText.split("\n");

  // Rest of the parseeWikicrow function remains the same
  const rootTitle = lines[0].replace(/^#+\s*/, "").trim();
  const sectionPattern = /^(#+)\s*(.*?)\s*$/;

  const structuredData: Section[] = [];
  let currentHierarchy = [rootTitle];
  let currentTitle = rootTitle;
  let currentContent = "";

  structuredData.push({
    title: currentTitle,
    content: "",
    hierarchy: currentHierarchy.join(" > "),
  });

  for (const line of lines.slice(1)) {
    const sectionMatch = line.match(sectionPattern);

    if (sectionMatch) {
      if (currentContent || currentHierarchy.length > 1) {
        structuredData.push({
          title: currentTitle,
          content: currentContent.trim(),
          hierarchy: currentHierarchy.join(" > "),
        });
      }

      const level = sectionMatch[1].length;
      currentTitle = sectionMatch[2].trim();
      currentHierarchy = [
        ...currentHierarchy.slice(0, level - 1),
        currentTitle,
      ];
      currentContent = "";
    } else {
      currentContent += line.trim() + " ";
    }
  }

  if (currentContent || currentHierarchy.length > 1) {
    structuredData.push({
      title: currentTitle,
      content: currentContent.trim(),
      hierarchy: currentHierarchy.join(" > "),
    });
  }

  return {
    data: [
      structuredData[0],
      ...structuredData
        .slice(1)
        .filter((section) => section.content || section.hierarchy !== rootTitle)
        .map((section) => {
          if (filePath.includes("wikicrow")) {
            if (section.title === "References" && section.content) {
              return {
                ...section,
                content: "",
                citations: processRefs(section.content),
              };
            }
          }

          if (section.title === "References" && section.content) {
            return {
              ...section,
              content: "",
              citations: parseWikipediaReferences(section.content),
            };
          }

          return section;
        }),
    ],
  };
}

export const parseWikipediaReferences = (
  input: string
): { citation: string; link: string }[] => {
  // ... existing implementation remains the same ...
  const pattern = /\[(\d+)\] ([^()]+) \((https?:\/\/[^\s]+)\)/g;
  const results: { id: string; text: string; url: string }[] = [];
  let match: RegExpExecArray | null;

  while ((match = pattern.exec(input)) !== null) {
    const id = match[1];
    const text = match[2].trim();
    const url = match[3];

    results.push({ id, text, url });
  }

  return input
    .split("\n")
    .map((line) => line.trim())
    .filter((line) => line.length > 0)
    .map((reference) => {
      const linkMatch = reference.match(/\((https?:\/\/[^\s)]+)\)/);
      const link = linkMatch ? linkMatch[1] : "";
      const citation = reference.replace(/\s*\(https?:\/\/[^\s)]+\)\s*$/, "");
      return {
        citation: citation.trim(),
        link: link,
      };
    });
};

================
File: lib/types.ts
================
// Classification types
export type RequirementClassification =
  | "Imperative Standards"
  | "Best Practices"
  | "Flexible Guidelines"
  | "Contextual Considerations";

// Single requirement
export interface Requirement {
  id: string;
  description: string;
  reference?: string;
  classification: RequirementClassification;
  category: string;
  where: string;
  when: string;
}

// Group of requirements
export interface RequirementGroup {
  description: string;
  requirements: Requirement[];
}

// Full requirements index
export interface RequirementsIndex {
  groups: {
    [key: string]: Requirement[]; // Updated to reflect the new structure
  };
}

// Props for the sidebar component
export interface RequirementsSidebarProps {
  groups: RequirementsIndex["groups"];
  onFilterChange: (
    searchQuery: string,
    classification: RequirementClassification | null
  ) => void;
}

// Rest of your types remain the same...
export interface RequirementProps {
  requirement: Requirement;
}

export interface Section {
  title: string;
  content: string;
  hierarchy: string;
  citations?: Citation[];
}

export interface Citation {
  citation: string;
  link: string;
}

export interface RequirementEvaluation {
  requirement_id: string;
  applicable: boolean;
  applicability_reasoning: string;
  score: number;
  confidence: number;
  evidence: string;
  reasoning: string;
  overlap_notes: string;
}

export interface FeedbackCategory {
  title: string;
  requirement_evaluations: RequirementEvaluation[];
  meta_notes: string;
}

export interface Feedback {
  [category: string]: FeedbackCategory[];
}

export interface ArticleSection {
  title: string;
  content: string;
  hierarchy: string;
  feedback: Feedback;
  citations?: { citation: string; link: string }[];
}

export interface CategoryScore {
  score: number;
  lastCalculated: Date;
  evaluations: RequirementEvaluation[];
}

export interface SectionState {
  isExpanded: boolean;
  lastViewed: Date;
  scores: Record<string, CategoryScore>;
}

================
File: lib/utils.ts
================
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export const processRefs = (
  input: string
): { citation: string; link: string }[] =>
  input
    .replace(/\s+/g, " ")
    .trim()
    .split(/(?=\[\d+\.\s+\([^)]+\)\s+)/)
    .map((ref) => ref.trim())
    .filter((ref) => ref.length > 0)
    .map((reference) => {
      let processed = reference.replace(/^\[\d+\.\s+\([^)]+\)\s+/, "");

      const linkMatch = processed.match(/\]\((https?:\/\/[^\s)]+)/);
      const link = linkMatch ? linkMatch[1] : "";

      // Remove the "URL: http://dx.doi.org/..." part
      processed = processed.replace(
        /URL:\s*http:\/\/dx\.doi\.org\/[^,]+,\s*/,
        ""
      );

      processed = processed.replace(/\]\(.*\)$/, "");

      return {
        citation: processed.trim(),
        link: link,
      };
    });
